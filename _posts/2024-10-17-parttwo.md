---
layout: single
title: "Part 02. 조건문과 반복문"
---

원래 PS의 기초는 무지성 `if`와 `for`이 기본 아니겠는가. 입출력 다음 가는 근본 문법인 조건문과 반복문을 공부할 차례다. 사실 C와 C++은 크게 차이가 없어서 C의 `if`와 `for` 문법을 그대로 사용하면 된다.

### Chapter 1. if/else if/else 윤년 문제

내 생각에는 출력 파트에 “Hello World!”가 있다면 조건문 파트에는 윤년 문제가 있다고 생각한다. 거의 전 세계 국룰 문제 수준으로 출제되는 윤년인데, 이게 은근히 수학적 사고력을 요구해서 나름 생각을 좀 해야 하는 문제다.

요약하자면 윤년은 연도가 4의 배수일 때 돌아오지만, 100의 배수일 때는 윤년이 아니다. 그런데 400의 배수일 때는 윤년이다. 그래서 2024년은 4의 배수라 윤년, 1900년은 4의 배수지만 100의 배수라 윤년이 아니고, 2000년은 100의 배수지만 400의 배수라 윤년이다.

```cpp
#include <iostream>
using namespace std;
int main() {
	int year;
	cin >> year;
	if (year % 400 == 0) /* 400의 배수일 때 */
		cout << 1;
	else if (year % 100 == 0) /* 400의 배수가 아니면서 100의 배수일 때 */
		cout << 0;
	else if (year % 4 == 0) /* 400의 배수도, 100의 배수도 아니면서 4의 배수일 때 */
		cout << 1;
	else; /* 어느 경우에도 해당하지 않을 때 */
		cout << 0;
		
	return 0;
}
```

`if`에서 `else`까지는 하나의 덩어리라고 생각하면 된다. 만약 `else if`나 `else`를 사용하지 않고 `if`로만 코드를 작성한다면 `year` 변수가 모든 if문을 만족하는지 하나하나 체크해야 하지만, `else if`와 `else`를 사용하면, 만족하는 라인을 발견하는 순간 아래 if문은 검사하지 않고 바로 프로그램이 종료된다.

윤년을 찾는 알고리즘은 더 효율적인 게 있을 수도 있겠으나 어차피 저렇게 써도 런타임에 문제도 없고… 난 그냥 제출했다.

### Chapter 2. for 반복문

반복문은 크게 `for`나 `while`이 있는데 난 `for`를 더 좋아한다. 그냥 얘가 더 정이 가고 반복문이 얼마나 돌아가는지 직관적으로 보인다 해야 하나? `while`은 `while (1)`로 써서 무한루프 돌릴 때 빼고는 안 쓴다.

```cpp
for (초기식; 조건식; 변화식) {
	/* code */
}
```

`for`문은 콜론(;)을 기준으로 반복문의 작동 횟수를 카운트할 변수를 선언하는 초기식, 반복문이 작동되는 조건을 명시해놓는 조건식, 그리고 반복문이 한 번 돌 때마다 카운트 변수를 어떻게 변화시킬지 알려주는 변화식으로 구성된다.

대표적인 구구단 출력 문제로 예를 들면 아래와 같다.

```cpp
int n;
cin >> n;

for (int i = 1; i <= 9; i++)
	cout << n << " * " << i << " = " << n * i;
```

반복문의 작동 횟수를 `i`라는 변수를 통해 셀 것이다. 먼저 `i`가 1일 때부터 시작한다. 이 반복문은 i가 9 이하이면 계속 작동하도록 해놓는다. 근데 `i`는 1이라고 네가 적어놨잖아? 그럼 안 끝나는 거 아니야? 그래서 변화식에 `i++`를 적어놓았다. ++ 연산자는 `i`의 값을 1씩 증가시킨다는 뜻이다. 즉, 반복문이 한 번 돌 때마다 `i`가 1씩 증가해서 2, 3, 4 순으로 값이 바뀐다. 반복문이 아홉 번 작동되면 `i`의 값이 10이 되고, 조건식을 만족하지 못하므로 반복문이 종료된다. 이런 원리로 딱 아홉 개의 구구단 식이 출력된다.

### Chapter 3. EOF(End of File)

시스템 프로그래밍 실습 수업 할 때 잠깐 배우고 넘어갔던 개념인데, 읽어온 파일이 끝나면 프로그램을 종료하도록 해주는 것이다. 대충 반복문의 탈출이랑 비슷한 건데, 리눅스 터미널에서처럼 ctrl+d로 강제 종료시키는 방법도 있고, 근데 코드를 써서 입력이 더 이상 나오지 않으면 무한루프에 빠지지 않고 프로그램을 종료시켜주는 착한 방법도 있다.

```cpp
if (cin.eof()) break;
```

이게 다다. 교양 코딩 수업 과제 보면 ‘입력을 계속 받다가 0이 입력되면 프로그램을 종료한다’ 같은 종료 조건을 주는데 이건 그냥 ‘입력이 없으면 프로그램을 종료한다’ 정도의 비슷한 느낌이다.

### Chapter 4. 실행시간 단축

상당히 생소한 개념이 하나 등장했다. `cin.tie(NULL)`과 `sync_with_stdio(false)`를 사용해서 실행시간을 단축시키는 것이다. 사실 이 문제는 그냥 뭘 써야 되는지 알려주기 때문에 정답을 맞히는 데는 무리가 없다. 다만 저 두 개의 문장이 뭘 의미하는지, 또 `endl` 대신에 `“\n”`을 개행으로 사용하라는 이유가 뭔지… 좀 공부해봤다.

- 버퍼(buffer)

![image](https://blog.kakaocdn.net/dn/bpBFQ8/btrpiIIKq4c/k92yX0rbQGG9EXsCYDcRr0/img.png)

메모리 할당 다음으로 느린 게 입출력이다. 대체 컴퓨터에 글 쓰고 글 보는 게 뭐가 오래 걸리냐는 의문이 들겠지만 수만 번의 입출력 반복이 있다고 생각하면 그 지연이 꽤 눈에 띄게 보일 것이다. 그래서 컴퓨터가 선택한 방법은 키보드로 친 글자를 버퍼라는 임시 공간에 일단은 모아놨다가, 엔터를 치는 등의 신호가 들어오면 모아놓은 글자를 한 번에 보여주는 것이다.

`cin.tie(NULL)`, `sync_with_stdio(false)`, `\n` 이런 것들은 모두 버퍼의 접근이나 연결 상태를 건드려 실행시간을 단축시키는 방법들이다.

```cpp
cin.tie(NULL)
```

`cin`은 우리가 아는 그 입력 `cin`이다. `tie`는 묶여있다, 엮여있다는 뜻이고, `NULL`은 없는 상태로 돌린다는 것이니, 모아서 얘기하면 `cin`을 풀어준다는 것이다. 어디서? `cout`와의 연결을 풀어준다. `cin`과 `cout`는 묶여 있는데, `cin`에 입력을 할 때마다 `cout`는 flush, 즉 버퍼 내용을 출력하고 그걸 전부 비우기까지 하는 일을 한다.

flush는 오래 걸리는 작업이고, 특히 BOJ에서는 flush를 그렇게 자주 할 필요가 없다. 프로그램을 다 돌린 후에 결과만 맞으면 장땡이니까, 출력 하나 할 때마다 버퍼를 비우고 그렇게 FM대로 안 해도 된다는 것이다.

```cpp
cout << a + b << "\n"
```

`endl` 대신 `\n`을 쓰라는 것도 비슷한 맥락이다. `endl`은 개행뿐만 아니라 출력 버퍼의 flush까지 함께 수행한다. 일은 좀 열심히 하지만, 오래 걸리는 친구다. `\n`은 flush를 하지 않는다. 귀찮아서 버퍼를 비우는 일을 안 하지만 그래도 덕분에 일은 좀 빨리 하니 럭키비키. 그래서 실행시간을 단축하고 싶으면 `“\n”`을 쓰는 방법이 있다.

```cpp
sync_with_stdio(false)
```

얘도 비슷하게 버퍼에 대한 접근을 조작해주는 건데, 일반적으로 C와 C++은 같은 버퍼를 공유한다. 그러니까 C++과 C는 stream이라고 불리는 데이터의 통로를 함께 쓰며 같은 버퍼를 사용 중이라는 것이다. iostream을 쓰는 C++ 헤더와 stdio를 쓰는 C 헤더가 같은 통로(stream)와 보관장소(buffer)를 쓰면 여간 불편한 게 아닐 것이다.

특히 난 코드를 쓸 때 stdio 입출력인 `scanf`, `getchar` 이런 거 쓰지도 않을 건데! 그래서 동기화를 끊어주는 게 `sync_with_stdio(false)`라는 문장이다. 한 마디로 stdio 헤더와의 동기화(sycronization)를 없애서 C++의 단독 버퍼를 제공해주겠다는 것이다. 이제 이 프로그램의 버퍼는 C++만의 무릉도원이므로 훨씬 실행시간이 단축되었지만 C는 배제되었기 때문에 `scanf` 같은 stdio의 입출력은 못 쓴다.

코드야 뭐 어려운 문제도 아니고 쉽게 넘어갔지만, stream, flush, buffer… 이런 개념들이 여전히 너무 생소하고 직관적으로 받아들이기 힘들어진다. 근데 그냥 컴퓨터의 세상에는 이런 움직임이 있고 이런 아이디어가 있구나 정도로 이해하고 넘어가야 할 것 같다.
